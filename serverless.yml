# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: kjpersonal
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: orsa
# "service" is the name of this project. This will also be added to your AWS resource names.
service: orsa-admin-backend

plugins:
  - serverless-offline

provider:
  name: aws
  runtime: nodejs20.x
  region: eu-west-3
  stage: ${opt:stage, 'dev'}
  profile: orsa
  httpApi:
    cors:
      allowedOrigins:
        - "https://orsa-admin.vercel.app"
        - "http://localhost:3000" # For local development
      allowedHeaders:
        - Content-Type # Essential for JSON requests
        - Authorization # For authentication tokens
        - X-Requested-With # Common for AJAX/fetch requests
        - X-Api-Key # If you plan to use API keys
        - Accept # For content negotiation
        - X-Filename # For binary uploads with filename
      allowedMethods:
        - GET
        - POST
        - PUT
        - DELETE
        - OPTIONS
      allowCredentials: true
      maxAge: 86400 # 24 hours
    # Enable binary media types for image uploads
    payload: "2.0"
    disableDefaultEndpoint: false
  # VPC Configuration moved to individual functions that need database access
  # Authentication functions (validateToken, validateAdminToken, cognitoAuthorizer)
  # are kept outside VPC to access Cognito service
  # Configure environment variables (these will be available in Lambda)
  # Note: We're using hardcoded values for now. In production, use secure ways to handle credentials
  # such as AWS Systems Manager Parameter Store or AWS Secrets Manager
  environment:
    # Update these values with your actual database information
    DB_HOST: "orsa-ecommerce.cjkwgkcwoyr0.eu-west-3.rds.amazonaws.com" # UPDATE THIS
    DB_USER: "admin" # UPDATE THIS if different
    DB_PASSWORD: "[[E<fWsd0CK02s6O-b)>tjxi3Fnp" # UPDATE THIS
    DB_NAME: "Orsa"
    DB_PORT: "3306" # S3 bucket for product images
    S3_BUCKET_NAME: "${self:service}-product-images-${self:provider.stage}"
    S3_REGION: "${self:provider.region}"
    # Cognito configuration - HARDCODED VALUES
    COGNITO_USER_POOL_ID: "eu-west-3_hjGfLZ4ek"
    COGNITO_CLIENT_ID: "28esv8q77dl3r2goi1mskl0ilb"
    COGNITO_REGION: "eu-west-3"
    STAGE: "${self:provider.stage}"  # IAM role permissions
  iam:
    role:
      statements:
        # Allow Lambda to access VPC resources (RDS)
        - Effect: Allow
          Action:
            - ec2:CreateNetworkInterface
            - ec2:DescribeNetworkInterfaces
            - ec2:DeleteNetworkInterface
            - ec2:AssignPrivateIpAddresses
            - ec2:UnassignPrivateIpAddresses
          Resource: "*"
        # Allow Lambda-to-Lambda invocation for external authentication
        - Effect: Allow
          Action:
            - lambda:InvokeFunction
          Resource: "arn:aws:lambda:${self:provider.region}:*:function:${self:service}-${self:provider.stage}-authenticateUser"
        # Allow Lambda to access S3 for product images
        - Effect: Allow
          Action:
            - s3:PutObject
            - s3:DeleteObject
            - s3:GetObject
          Resource: "arn:aws:s3:::${self:service}-product-images-${self:provider.stage}/*"
        - Effect: Allow
          Action:
            - s3:ListBucket
          Resource: "arn:aws:s3:::${self:service}-product-images-${self:provider.stage}"

# Package configuration
package:
  individually: true
  patterns:
    - "!node_modules/.cache/**"
    - "!.env"
    - "!.git/**"

# Custom configurations if needed
custom:
  timeout: 25 # Default timeout for all functions (25 seconds, under HTTP API limit)

  # VPC configuration for functions that need database access
  vpcConfig:
    securityGroupIds:
      - sg-06745c25a3b52833b # RDS security group ID
    subnetIds:
      - subnet-0c6d5836c444e066b # Private subnet IDs
      - subnet-028206bbed10db409
      - subnet-0092491643bdfa079

functions:
  # Dedicated authentication function (outside VPC for Cognito access)
  authenticateUser:
    handler: authHandler.authenticateUser
    timeout: 30
    environment:
      SERVICE: ${self:service}
      STAGE: ${self:provider.stage}

  # Cognito Lambda Authorizer
  cognitoAuthorizer:
    handler: authHandler.authorizer
    timeout: 30

  # Authentication validation endpoints
  validateToken:
    handler: protectedHandler.validateToken
    events:
      - httpApi:
          path: /auth/validate
          method: get
    timeout: ${self:custom.timeout}

  validateAdminToken:
    handler: protectedHandler.validateAdminToken
    events:
      - httpApi:
          path: /auth/validate-admin
          method: get
    timeout: ${self:custom.timeout}
  # Test function to debug connectivity and permissions
  testDbConnection:
    handler: protectedHandler.testDbConnection
    events:
      - httpApi:
          path: /test-connection
          method: get
    timeout: 60 # Longer timeout for debugging
    vpc: ${self:custom.vpcConfig} # Product endpoints
  getProducts:
    handler: protectedHandler.getProducts
    events:
      - httpApi:
          path: /products
          method: get
      - httpApi:
          path: /products/{id}
          method: get
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}
    environment:
      VPC_FUNCTION: "true"
      SERVICE: ${self:service}
      STAGE: ${self:provider.stage}

  createProduct:
    handler: protectedHandler.createProduct
    events:
      - httpApi:
          path: /products
          method: post
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

  updateProduct:
    handler: protectedHandler.updateProduct
    events:
      - httpApi:
          path: /products/{id}
          method: put
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

  deleteProduct:
    handler: protectedHandler.deleteProduct
    events:
      - httpApi:
          path: /products/{id}
          method: delete
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}
  # User endpoints
  getUsers:
    handler: protectedHandler.getUsers
    events:
      - httpApi:
          path: /users
          method: get
      - httpApi:
          path: /users/{id}
          method: get
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

  createUser:
    handler: protectedHandler.createUser
    events:
      - httpApi:
          path: /users
          method: post
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

  updateUser:
    handler: protectedHandler.updateUser
    events:
      - httpApi:
          path: /users/{id}
          method: put
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

  deleteUser:
    handler: protectedHandler.deleteUser
    events:
      - httpApi:
          path: /users/{id}
          method: delete
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}
  # Order endpoints
  getOrders:
    handler: protectedHandler.getOrders
    events:
      - httpApi:
          path: /orders
          method: get
      - httpApi:
          path: /orders/{id}
          method: get
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

  createOrder:
    handler: protectedHandler.createOrder
    events:
      - httpApi:
          path: /orders
          method: post
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

  updateOrder:
    handler: protectedHandler.updateOrder
    events:
      - httpApi:
          path: /orders/{id}
          method: put
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

  deleteOrder:
    handler: protectedHandler.deleteOrder
    events:
      - httpApi:
          path: /orders/{id}
          method: delete
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}
  getTotalPrice:
    handler: protectedHandler.getTotalPrice
    events:
      - httpApi:
          path: /orders/total-price
          method: get
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig} # Order item endpoints
  addOrderItem:
    handler: protectedHandler.addOrderItem
    events:
      - httpApi:
          path: /orders/{id}/items
          method: post
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

  removeOrderItem:
    handler: protectedHandler.removeOrderItem
    events:
      - httpApi:
          path: /orders/items/{itemId}
          method: delete
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}
  # Product Image endpoints
  uploadProductImage:
    handler: protectedHandler.uploadProductImage
    events:
      - httpApi:
          path: /products/images/upload
          method: post
    timeout: 30 # Reduced to match HTTP API limit
    vpc: ${self:custom.vpcConfig}

  deleteProductImage:
    handler: protectedHandler.deleteProductImage
    events:
      - httpApi:
          path: /products/images/{imageKey}
          method: delete
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

  # Product Image Database Record endpoints
  getProductImages:
    handler: protectedHandler.getProductImages
    events:
      - httpApi:
          path: /products/{productId}/images
          method: get
      - httpApi:
          path: /products/images/{imageId}
          method: get
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

  createProductImageRecord:
    handler: protectedHandler.createProductImageRecord
    events:
      - httpApi:
          path: /products/images/record
          method: post
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}
  updateProductImageRecord:
    handler: protectedHandler.updateProductImageRecord
    events:
      - httpApi:
          path: /products/images/record/{imageId}
          method: put
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

  setPrimaryProductImage:
    handler: protectedHandler.setPrimaryProductImage
    events:
      - httpApi:
          path: /products/{productId}/images/{imageId}/primary
          method: put
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

  deleteProductImageRecord:
    handler: protectedHandler.deleteProductImageRecord
    events:
      - httpApi:
          path: /products/images/record/{imageId}
          method: delete
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

  deleteProductImages:
    handler: protectedHandler.deleteProductImages
    events:
      - httpApi:
          path: /products/{productId}/images
          method: delete
    timeout: ${self:custom.timeout}
    vpc: ${self:custom.vpcConfig}

# AWS Resources
resources:
  Resources: # S3 Bucket for Product Images
    ProductImagesBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: ${self:service}-product-images-${self:provider.stage}
        PublicAccessBlockConfiguration:
          BlockPublicAcls: true # Block ACLs since we use bucket policy
          BlockPublicPolicy: false # Allow bucket policy for public read
          IgnorePublicAcls: true # Ignore existing ACLs
          RestrictPublicBuckets: false # Allow bucket policy
        CorsConfiguration:
          CorsRules:
            - AllowedHeaders: ["*"]
              AllowedMethods: [GET, PUT, POST, DELETE, HEAD]
              AllowedOrigins: ["*"]
              MaxAge: 3000

    # Bucket Policy for Public Read Access
    ProductImagesBucketPolicy:
      Type: AWS::S3::BucketPolicy
      Properties:
        Bucket: !Ref ProductImagesBucket
        PolicyDocument:
          Statement:
            - Sid: PublicReadGetObject
              Effect: Allow
              Principal: "*"
              Action: "s3:GetObject"
              Resource: !Sub "${ProductImagesBucket.Arn}/*"

  Outputs:
    ProductImagesBucketName:
      Description: "Name of the S3 bucket for product images"
      Value: !Ref ProductImagesBucket
      Export:
        Name: ${self:service}-${self:provider.stage}-ProductImagesBucket

    ProductImagesBucketUrl:
      Description: "Public URL of the S3 bucket for product images"
      Value: !Sub "https://${ProductImagesBucket}.s3.${self:provider.region}.amazonaws.com"
      Export:
        Name: ${self:service}-${self:provider.stage}-ProductImagesBucketUrl
